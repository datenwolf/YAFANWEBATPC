
/* die kommen später in nen globalen header.

typedef struct {
	int id=0;
	int damagepershot=0;
	int shotspermagazine=0;
	bool usesMagazine=false;
	int magazineID=0;
	int energypershot=0;
	int type=0;
} weapon;
typedef struct {
	float x,y,z;
	int type;
	weapon[] weapons;
} spaceObject;
spaceObject[] global_objects;
#define WEAPON_EXTRACTOR 50
#define EVENT_ATTACKED 100
event getEvent(int id, int type);//returns oldest of ID's events of TYPE.
*/
	void AIloop(int me) {
		int attacker;//problem gelöst
		while isAlive(me){
			int target;
			event atkevent=getEvent(me,EVENT_ATTACKED);
			if(atkevent != NULL)
				attacker=atkevent.attacker;
			if(attacker != 0 && isAlive(attacker)) {
				if (lookAt(me, attacker))
					throttleHelper(me,attacker);
				if(canFireAt(me, attacker))
					fire(me,attacker, getBestWeapon(me));
			} else if( (target = getNextAttackable(me)) != null) {
				if (lookAt(me, target))
					throttleHelper(me, target);
				if(canFireAt(me, target))
					fire(me,attacker, getWeaponWithMostAmmunition(me));
			} else if (getWeaponByType(me,WEAPON_EXTRACTOR)!=NULL && (target = getNextValuableObject(me)) != null) {
				fire(me,target, getWeaponByType(me,WEAPON_EXTRACTOR)); //Extractor trifft immer -> kein Check und keine Rotation
			}
		}
	}

	void throttleHelper(int me, target target) {
		float distance = getDistanceBetween(me, target);
		if(distance > 20) 
			throttle( (distance - 20) * 10 );
		else if (distance < 11) 
			throttle( -90 + (distance * 10) );
	}

	int getWeaponByType(int me, int type) {
		int i;
		for(i=0;i<(sizeof(global_objects[me].weapons)/sizeof(global_objects[me].weapons[0]));i++){
			if(global_objects[me].weapons[i].type==type){
				return i;
			}
	  	}
	  	return NULL;
	}
	int getWeaponWithMostAmmunition(int me) {
		int i;
		int found=-1;
		int gammo=0;
		int foundenergy=-1;
		for(i=0;i<(sizeof(global_objects[me].weapons)/sizeof(global_objects[me].weapons[0]));i++){
			if(!global_objects[me].weapons[i].usesMagazine){
				foundenergy=i;
			}
			int ammo=global_objects[me].weapons[i].ammo;
			if(ammo>gammo){
				gammo=ammo;
				found=i;
		  	}
	  	}
	  	if(found==-1){
	  		found=foundenergy;
  		}
	  	return found;
	}

	int getBestWeapon(int me) {
		int i;
		int found=0;
		int gdamage=0;
		for(i=0;i<(sizeof(global_objects[me].weapons)/sizeof(global_objects[me].weapons[0]));i++){
			int damage=global_objects[me].weapons[i].damagepershot;
			if(damage>gdamage && (!global_objects[me].weapons[i].usesMagazine || global_objects[me].weapons[i].ammo > 0){
				gdamage=damage;
				found=i;
		  	}
	  	}
	  	return found;
	}

/*kommentare
lookAt: richtet das Raumschiff so aus, dass es zum Gegner fliegt, wenn es nach vorne fliegt, gibt zurück, ob diese Bedingungen schon erfüllt sind
canFireAt: gibt zurück, ob ich mit der aktuellen Rotation des Schiffes den Gegner treffen kann
getDistanceBetween: entfernung der Oberflächen der übergebenen Objekte
throttle: Gibt die Energie auf den Hauptantrieb in % an (-% heißt rückwärts)
fire: Feuert mit der angegebenen Waffe auf das angegebene Objekt
getNextAttackable: Liefert das angreifbare Objekt, welches der KI am nächsten ist
getNextValuableObject: Liefert das aufnehmbare Objekt, welches der KI am nächsten ist
isAlive: Prüft, ob die übergebene Referenz als Objekt existiert
*/
